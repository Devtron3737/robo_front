{"ast":null,"code":"/**\n * Parse takes a string of CSV data and converts it to a 2 dimensional array\n *\n * options\n * - typed - infer types [false]\n *\n * @static\n * @param {string} csv the CSV string to parse\n * @param {Object} [options] an object containing the options\n * @param {Function} [reviver] a custom function to modify the values\n * @returns {Array} a 2 dimensional array of `[entries][values]`\n */\nexport function parse(csv, options) {\n  let reviver = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : v => v;\n  const ctx = Object.create(null);\n  ctx.options = options || {};\n  ctx.reviver = reviver;\n  ctx.value = '';\n  ctx.entry = [];\n  ctx.output = [];\n  ctx.col = 1;\n  ctx.row = 1;\n  const lexer = /\"|,|\\r\\n|\\n|\\r|[^\",\\r\\n]+/y;\n  const isNewline = /^(\\r\\n|\\n|\\r)$/;\n  let matches = [];\n  let match = '';\n  let state = 0;\n\n  while ((matches = lexer.exec(csv)) !== null) {\n    match = matches[0];\n\n    switch (state) {\n      case 0:\n        // start of entry\n        switch (true) {\n          case match === '\"':\n            state = 3;\n            break;\n\n          case match === ',':\n            state = 0;\n            valueEnd(ctx);\n            break;\n\n          case isNewline.test(match):\n            state = 0;\n            valueEnd(ctx);\n            entryEnd(ctx);\n            break;\n\n          default:\n            ctx.value += match;\n            state = 2;\n            break;\n        }\n\n        break;\n\n      case 2:\n        // un-delimited input\n        switch (true) {\n          case match === ',':\n            state = 0;\n            valueEnd(ctx);\n            break;\n\n          case isNewline.test(match):\n            state = 0;\n            valueEnd(ctx);\n            entryEnd(ctx);\n            break;\n\n          default:\n            state = 4;\n            throw Error(`CSVError: Illegal state [row:${ctx.row}, col:${ctx.col}]`);\n        }\n\n        break;\n\n      case 3:\n        // delimited input\n        switch (true) {\n          case match === '\"':\n            state = 4;\n            break;\n\n          default:\n            state = 3;\n            ctx.value += match;\n            break;\n        }\n\n        break;\n\n      case 4:\n        // escaped or closing delimiter\n        switch (true) {\n          case match === '\"':\n            state = 3;\n            ctx.value += match;\n            break;\n\n          case match === ',':\n            state = 0;\n            valueEnd(ctx);\n            break;\n\n          case isNewline.test(match):\n            state = 0;\n            valueEnd(ctx);\n            entryEnd(ctx);\n            break;\n\n          default:\n            throw Error(`CSVError: Illegal state [row:${ctx.row}, col:${ctx.col}]`);\n        }\n\n        break;\n    }\n  } // flush the last value\n\n\n  if (ctx.entry.length !== 0) {\n    valueEnd(ctx);\n    entryEnd(ctx);\n  }\n\n  return ctx.output;\n}\n/**\n * Stringify takes a 2 dimensional array of `[entries][values]` and converts them to CSV\n *\n * options\n * - eof - add a trailing newline at the end of file [true]\n *\n * @static\n * @param {Array} array the input array to stringify\n * @param {Object} [options] an object containing the options\n * @param {Function} [replacer] a custom function to modify the values\n * @returns {string} the CSV string\n */\n\nexport function stringify(array) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let replacer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : v => v;\n  const ctx = Object.create(null);\n  ctx.options = options;\n  ctx.options.eof = ctx.options.eof !== undefined ? ctx.options.eof : true;\n  ctx.row = 1;\n  ctx.col = 1;\n  ctx.output = '';\n  const needsDelimiters = /\"|,|\\r\\n|\\n|\\r/;\n  array.forEach((row, rIdx) => {\n    let entry = '';\n    ctx.col = 1;\n    row.forEach((col, cIdx) => {\n      if (typeof col === 'string') {\n        col = col.replace(/\"/g, '\"\"');\n        col = needsDelimiters.test(col) ? `\"${col}\"` : col;\n      }\n\n      entry += replacer(col, ctx.row, ctx.col);\n\n      if (cIdx !== row.length - 1) {\n        entry += ',';\n      }\n\n      ctx.col++;\n    });\n\n    switch (true) {\n      case ctx.options.eof:\n      case !ctx.options.eof && rIdx !== array.length - 1:\n        ctx.output += `${entry}\\n`;\n        break;\n\n      default:\n        ctx.output += `${entry}`;\n        break;\n    }\n\n    ctx.row++;\n  });\n  return ctx.output;\n}\n/** @private */\n\nfunction valueEnd(ctx) {\n  const value = ctx.options.typed ? inferType(ctx.value) : ctx.value;\n  ctx.entry.push(ctx.reviver(value, ctx.row, ctx.col));\n  ctx.value = '';\n  ctx.col++;\n}\n/** @private */\n\n\nfunction entryEnd(ctx) {\n  ctx.output.push(ctx.entry);\n  ctx.entry = [];\n  ctx.row++;\n  ctx.col = 1;\n}\n/** @private */\n\n\nfunction inferType(value) {\n  const isNumber = /.\\./;\n\n  switch (true) {\n    case value === 'true':\n    case value === 'false':\n      return value === 'true';\n\n    case isNumber.test(value):\n      return parseFloat(value);\n\n    case isFinite(value):\n      return parseInt(value);\n\n    default:\n      return value;\n  }\n}","map":{"version":3,"sources":["/Users/devin/Desktop/projects/robo/robo_front/node_modules/@vanillaes/csv/index.js"],"names":["parse","csv","options","reviver","v","ctx","Object","create","value","entry","output","col","row","lexer","isNewline","matches","match","state","exec","valueEnd","test","entryEnd","Error","length","stringify","array","replacer","eof","undefined","needsDelimiters","forEach","rIdx","cIdx","replace","typed","inferType","push","isNumber","parseFloat","isFinite","parseInt"],"mappings":"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","sourcesContent":["/**\n * Parse takes a string of CSV data and converts it to a 2 dimensional array\n *\n * options\n * - typed - infer types [false]\n *\n * @static\n * @param {string} csv the CSV string to parse\n * @param {Object} [options] an object containing the options\n * @param {Function} [reviver] a custom function to modify the values\n * @returns {Array} a 2 dimensional array of `[entries][values]`\n */\nexport function parse (csv, options, reviver = v => v) {\n  const ctx = Object.create(null)\n  ctx.options = options || {}\n  ctx.reviver = reviver\n  ctx.value = ''\n  ctx.entry = []\n  ctx.output = []\n  ctx.col = 1\n  ctx.row = 1\n\n  const lexer = /\"|,|\\r\\n|\\n|\\r|[^\",\\r\\n]+/y\n  const isNewline = /^(\\r\\n|\\n|\\r)$/\n\n  let matches = []\n  let match = ''\n  let state = 0\n\n  while ((matches = lexer.exec(csv)) !== null) {\n    match = matches[0]\n\n    switch (state) {\n      case 0: // start of entry\n        switch (true) {\n          case match === '\"':\n            state = 3\n            break\n          case match === ',':\n            state = 0\n            valueEnd(ctx)\n            break\n          case isNewline.test(match):\n            state = 0\n            valueEnd(ctx)\n            entryEnd(ctx)\n            break\n          default:\n            ctx.value += match\n            state = 2\n            break\n        }\n        break\n      case 2: // un-delimited input\n        switch (true) {\n          case match === ',':\n            state = 0\n            valueEnd(ctx)\n            break\n          case isNewline.test(match):\n            state = 0\n            valueEnd(ctx)\n            entryEnd(ctx)\n            break\n          default:\n            state = 4\n            throw Error(`CSVError: Illegal state [row:${ctx.row}, col:${ctx.col}]`)\n        }\n        break\n      case 3: // delimited input\n        switch (true) {\n          case match === '\"':\n            state = 4\n            break\n          default:\n            state = 3\n            ctx.value += match\n            break\n        }\n        break\n      case 4: // escaped or closing delimiter\n        switch (true) {\n          case match === '\"':\n            state = 3\n            ctx.value += match\n            break\n          case match === ',':\n            state = 0\n            valueEnd(ctx)\n            break\n          case isNewline.test(match):\n            state = 0\n            valueEnd(ctx)\n            entryEnd(ctx)\n            break\n          default:\n            throw Error(`CSVError: Illegal state [row:${ctx.row}, col:${ctx.col}]`)\n        }\n        break\n    }\n  }\n\n  // flush the last value\n  if (ctx.entry.length !== 0) {\n    valueEnd(ctx)\n    entryEnd(ctx)\n  }\n\n  return ctx.output\n}\n\n/**\n * Stringify takes a 2 dimensional array of `[entries][values]` and converts them to CSV\n *\n * options\n * - eof - add a trailing newline at the end of file [true]\n *\n * @static\n * @param {Array} array the input array to stringify\n * @param {Object} [options] an object containing the options\n * @param {Function} [replacer] a custom function to modify the values\n * @returns {string} the CSV string\n */\nexport function stringify (array, options = {}, replacer = v => v) {\n  const ctx = Object.create(null)\n  ctx.options = options\n  ctx.options.eof = ctx.options.eof !== undefined ? ctx.options.eof : true\n  ctx.row = 1\n  ctx.col = 1\n  ctx.output = ''\n\n  const needsDelimiters = /\"|,|\\r\\n|\\n|\\r/\n\n  array.forEach((row, rIdx) => {\n    let entry = ''\n    ctx.col = 1\n    row.forEach((col, cIdx) => {\n      if (typeof col === 'string') {\n        col = col.replace(/\"/g, '\"\"')\n        col = needsDelimiters.test(col) ? `\"${col}\"` : col\n      }\n      entry += replacer(col, ctx.row, ctx.col)\n      if (cIdx !== row.length - 1) {\n        entry += ','\n      }\n      ctx.col++\n    })\n    switch (true) {\n      case ctx.options.eof:\n      case !ctx.options.eof && rIdx !== array.length - 1:\n        ctx.output += `${entry}\\n`\n        break\n      default:\n        ctx.output += `${entry}`\n        break\n    }\n    ctx.row++\n  })\n\n  return ctx.output\n}\n\n/** @private */\nfunction valueEnd (ctx) {\n  const value = ctx.options.typed ? inferType(ctx.value) : ctx.value\n  ctx.entry.push(ctx.reviver(value, ctx.row, ctx.col))\n  ctx.value = ''\n  ctx.col++\n}\n\n/** @private */\nfunction entryEnd (ctx) {\n  ctx.output.push(ctx.entry)\n  ctx.entry = []\n  ctx.row++\n  ctx.col = 1\n}\n\n/** @private */\nfunction inferType (value) {\n  const isNumber = /.\\./\n\n  switch (true) {\n    case value === 'true':\n    case value === 'false':\n      return value === 'true'\n    case isNumber.test(value):\n      return parseFloat(value)\n    case isFinite(value):\n      return parseInt(value)\n    default:\n      return value\n  }\n}\n"]},"metadata":{},"sourceType":"module"}